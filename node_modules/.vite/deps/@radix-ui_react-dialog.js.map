{
  "version": 3,
  "sources": ["../../@radix-ui/react-dialog/node_modules/@radix-ui/react-slot/dist/packages/react/slot/src/Slot.tsx", "../../@radix-ui/react-focus-guards/dist/packages/react/focus-guards/src/FocusGuards.tsx", "../../@radix-ui/react-portal/dist/packages/react/portal/src/Portal.tsx", "../../@radix-ui/react-focus-scope/dist/packages/react/focus-scope/src/FocusScope.tsx", "../../@radix-ui/react-use-escape-keydown/dist/packages/react/use-escape-keydown/src/useEscapeKeydown.tsx", "../../@radix-ui/react-use-body-pointer-events/dist/packages/react/use-body-pointer-events/src/useBodyPointerEvents.tsx", "../../@radix-ui/react-dismissable-layer/dist/packages/react/dismissable-layer/src/DismissableLayer.tsx", "../../@radix-ui/react-dialog/dist/packages/react/dialog/src/Dialog.tsx"],
  "sourcesContent": ["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.Children.toArray(children).some(isSlottable)) {\n    return (\n      <>\n        {React.Children.map(children, (child) => {\n          return isSlottable(child) ? (\n            <SlotClone {...slotProps} ref={forwardedRef}>\n              {child.props.children}\n            </SlotClone>\n          ) : (\n            child\n          );\n        })}\n      </>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props),\n      ref: composeRefs(forwardedRef, (children as any).ref),\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(child: React.ReactNode): child is React.ReactElement {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    // if it's a handler, modify the override by composing the base handler\n    if (isHandler) {\n      overrideProps[propName] = (...args: unknown[]) => {\n        childPropValue?.(...args);\n        slotPropValue?.(...args);\n      };\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n", "import * as React from 'react';\n\n/** Number of components which have requested interest to have focus guards */\nlet count = 0;\n\nfunction FocusGuards(props: any) {\n  useFocusGuards();\n  return props.children;\n}\n\n/**\n * Injects a pair of focus guards at the edges of the whole DOM tree\n * to ensure `focusin` & `focusout` events can be caught consistently.\n */\nfunction useFocusGuards() {\n  React.useEffect(() => {\n    const edgeGuards = document.querySelectorAll('[data-radix-focus-guard]');\n    document.body.insertAdjacentElement('afterbegin', edgeGuards[0] ?? createFocusGuard());\n    document.body.insertAdjacentElement('beforeend', edgeGuards[1] ?? createFocusGuard());\n    count++;\n\n    return () => {\n      if (count === 1) {\n        document.querySelectorAll('[data-radix-focus-guard]').forEach((node) => node.remove());\n      }\n      count--;\n    };\n  }, []);\n}\n\nfunction createFocusGuard() {\n  const element = document.createElement('span');\n  element.setAttribute('data-radix-focus-guard', '');\n  element.tabIndex = 0;\n  element.style.cssText = 'outline: none; opacity: 0; position: fixed; pointer-events: none';\n  return element;\n}\n\nconst Root = FocusGuards;\n\nexport {\n  FocusGuards,\n  //\n  Root,\n  //\n  useFocusGuards,\n};\n", "import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst MAX_Z_INDEX = 2147483647;\n\n/* -------------------------------------------------------------------------------------------------\n * Portal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'Portal';\n\ntype PortalElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PortalProps extends PrimitiveDivProps {\n  containerRef?: React.RefObject<HTMLElement>;\n}\n\nconst Portal = React.forwardRef<PortalElement, PortalProps>((props, forwardedRef) => {\n  const { containerRef, style, ...portalProps } = props;\n  const hostElement = containerRef?.current ?? globalThis?.document?.body;\n  const [, forceUpdate] = React.useState({});\n\n  /**\n   * containerRef.current won't be set on first render, so we force a re-render.\n   * Because we do this in `useLayoutEffect`, we still avoid a flash.\n   */\n  useLayoutEffect(() => {\n    forceUpdate({});\n  }, []);\n\n  if (hostElement) {\n    return ReactDOM.createPortal(\n      <Primitive.div\n        data-radix-portal=\"\"\n        {...portalProps}\n        ref={forwardedRef}\n        style={\n          /**\n           * If the Portal is injected in `body`, we assume we want whatever is portalled\n           * to appear on top of everything. Ideally this would be handled by making sure the\n           * app root creates a new stacking context, however this is quite hard to automate.\n           * For this reason, we have opted for setting the max z-index on the portal itself.\n           */\n          hostElement === document.body\n            ? {\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                zIndex: MAX_Z_INDEX,\n                ...style,\n              }\n            : undefined\n        }\n      />,\n      hostElement\n    );\n  }\n\n  // bail out of ssr\n  return null;\n});\n\nPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * UnstablePortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst UNSTABLE_PORTAL_NAME = 'Portal';\n\ntype UnstablePortalElement = React.ElementRef<typeof Primitive.div>;\ninterface UnstablePortalProps extends PrimitiveDivProps {\n  container?: HTMLElement | null;\n}\n\nconst UnstablePortal = React.forwardRef<UnstablePortalElement, UnstablePortalProps>(\n  (props, forwardedRef) => {\n    const { container = globalThis?.document?.body, ...portalProps } = props;\n    return container\n      ? ReactDOM.createPortal(<Primitive.div {...portalProps} ref={forwardedRef} />, container)\n      : null;\n  }\n);\n\nUnstablePortal.displayName = UNSTABLE_PORTAL_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Portal;\n\nexport {\n  Portal,\n  UnstablePortal,\n  //\n  Root,\n};\nexport type { PortalProps, UnstablePortalProps };\n", "import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        if (!container.contains(event.relatedTarget as HTMLElement | null)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new Event(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new Event(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n", "import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\n/**\n * Listens for when the escape key is down\n */\nfunction useEscapeKeydown(onEscapeKeyDownProp?: (event: KeyboardEvent) => void) {\n  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        onEscapeKeyDown(event);\n      }\n    };\n    document.addEventListener('keydown', handleKeyDown);\n    return () => document.removeEventListener('keydown', handleKeyDown);\n  }, [onEscapeKeyDown]);\n}\n\nexport { useEscapeKeydown };\n", "import * as React from 'react';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\nlet changeCount = 0;\nlet originalBodyPointerEvents: string;\n\nfunction useBodyPointerEvents({ disabled }: { disabled: boolean }) {\n  const isTouchOrPenPressedRef = React.useRef(false);\n\n  useLayoutEffect(() => {\n    if (disabled) {\n      if (changeCount === 0) {\n        originalBodyPointerEvents = document.body.style.pointerEvents;\n      }\n\n      function resetPointerEvents() {\n        changeCount--;\n        if (changeCount === 0) {\n          document.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      }\n\n      document.body.style.pointerEvents = 'none';\n      changeCount++;\n\n      function handlePointerUp(event: PointerEvent) {\n        isTouchOrPenPressedRef.current = event.pointerType !== 'mouse';\n      }\n\n      document.addEventListener('pointerup', handlePointerUp);\n\n      return () => {\n        if (isTouchOrPenPressedRef.current) {\n          /**\n           * We force pointer-events to remain disabled until `click` fires on touch devices\n           * because browsers implement a ~350ms delay between the time the user stops\n           * touching the display and when the browser executes events. We need to ensure we\n           * don't reactivate pointer-events within this timeframe otherwise the browser may\n           * execute events that should have been prevented.\n           *\n           * We are aware that `touch-action: manipulation` shortens this delay for events,\n           * but it isn't enough to cover all cases.\n           *\n           * When there is an input on screen:\n           * - if a click event is bound to it, it will fire after a `pointerdown` which may\n           * have re-enabled pointer-events (regardless of `touch-action: manipulation`).\n           * - if clicking it causes the page to zoom, the events will wait for the zoom to\n           * finish before executing on the input.\n           * - if long pressing it, the events will execute after the longpress delay.\n           */\n          document.addEventListener('click', resetPointerEvents, { once: true });\n        } else {\n          resetPointerEvents();\n        }\n\n        document.removeEventListener('pointerup', handlePointerUp);\n      };\n    }\n  }, [disabled]);\n}\n\nexport { useBodyPointerEvents };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useBodyPointerEvents } from '@radix-ui/react-use-body-pointer-events';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    });\n\n    useBodyPointerEvents({ disabled: disableOutsidePointerEvents });\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) context.layersWithOutsidePointerEventsDisabled.add(node);\n      context.layers.add(node);\n      dispatchUpdate();\n    }, [node, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ElementRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(onPointerDownOutside?: (event: PointerDownOutsideEvent) => void) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        dispatchCustomEvent(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      document.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      document.removeEventListener('pointerdown', handlePointerDown);\n    };\n  }, [handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(onFocusOutside?: (event: FocusOutsideEvent) => void) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        dispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail);\n      }\n    };\n    document.addEventListener('focusin', handleFocus);\n    return () => document.removeEventListener('focusin', handleFocus);\n  }, [handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new Event(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction dispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never)\n) {\n  const target = detail.originalEvent.target as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n  return !target.dispatchEvent(event);\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext, createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { UnstablePortal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { Slot } from '@radix-ui/react-slot';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Dialog\n * -----------------------------------------------------------------------------------------------*/\n\nconst DIALOG_NAME = 'Dialog';\n\ntype ScopedProps<P> = P & { __scopeDialog?: Scope };\nconst [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);\n\ntype DialogContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement>;\n  contentRef: React.RefObject<DialogContentElement>;\n  contentId: string;\n  titleId: string;\n  descriptionId: string;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n  modal: boolean;\n  allowPinchZoom: DialogProps['allowPinchZoom'];\n};\n\nconst [DialogProvider, useDialogContext] = createDialogContext<DialogContextValue>(DIALOG_NAME);\n\ntype RemoveScrollProps = React.ComponentProps<typeof RemoveScroll>;\ninterface DialogProps {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  modal?: boolean;\n  /**\n   * @see https://github.com/theKashey/react-remove-scroll#usage\n   */\n  allowPinchZoom?: RemoveScrollProps['allowPinchZoom'];\n  children?: React.ReactNode;\n}\n\nconst Dialog: React.FC<DialogProps> = (props: ScopedProps<DialogProps>) => {\n  const {\n    __scopeDialog,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    modal = true,\n    allowPinchZoom,\n  } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentRef = React.useRef<DialogContentElement>(null);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n\n  return (\n    <DialogProvider\n      scope={__scopeDialog}\n      triggerRef={triggerRef}\n      contentRef={contentRef}\n      contentId={useId()}\n      titleId={useId()}\n      descriptionId={useId()}\n      open={open}\n      onOpenChange={setOpen}\n      onOpenToggle={React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen])}\n      modal={modal}\n      allowPinchZoom={allowPinchZoom}\n    >\n      {children}\n    </DialogProvider>\n  );\n};\n\nDialog.displayName = DIALOG_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'DialogTrigger';\n\ntype DialogTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface DialogTriggerProps extends PrimitiveButtonProps {}\n\nconst DialogTrigger = React.forwardRef<DialogTriggerElement, DialogTriggerProps>(\n  (props: ScopedProps<DialogTriggerProps>, forwardedRef) => {\n    const { __scopeDialog, ...triggerProps } = props;\n    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n    return (\n      <Primitive.button\n        type=\"button\"\n        aria-haspopup=\"dialog\"\n        aria-expanded={context.open}\n        aria-controls={context.contentId}\n        data-state={getState(context.open)}\n        {...triggerProps}\n        ref={composedTriggerRef}\n        onClick={composeEventHandlers(props.onClick, context.onOpenToggle)}\n      />\n    );\n  }\n);\n\nDialogTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'DialogPortal';\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof UnstablePortal>;\ninterface DialogPortalProps extends Omit<PortalProps, 'asChild'> {\n  children?: React.ReactNode;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogPortal: React.FC<DialogPortalProps> = (props: ScopedProps<DialogPortalProps>) => {\n  const { __scopeDialog, forceMount, children, container } = props;\n  const context = useDialogContext(PORTAL_NAME, __scopeDialog);\n  return (\n    <>\n      {React.Children.map(children, (child) => (\n        <Presence present={forceMount || context.open}>\n          <UnstablePortal asChild container={container}>\n            {child}\n          </UnstablePortal>\n        </Presence>\n      ))}\n    </>\n  );\n};\n\nDialogPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogOverlay\n * -----------------------------------------------------------------------------------------------*/\n\nconst OVERLAY_NAME = 'DialogOverlay';\n\ntype DialogOverlayElement = DialogOverlayImplElement;\ninterface DialogOverlayProps extends DialogOverlayImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogOverlay = React.forwardRef<DialogOverlayElement, DialogOverlayProps>(\n  (props: ScopedProps<DialogOverlayProps>, forwardedRef) => {\n    const { forceMount, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);\n    return context.modal ? (\n      <Presence present={forceMount || context.open}>\n        <DialogOverlayImpl {...overlayProps} ref={forwardedRef} />\n      </Presence>\n    ) : null;\n  }\n);\n\nDialogOverlay.displayName = OVERLAY_NAME;\n\ntype DialogOverlayImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DialogOverlayImplProps extends PrimitiveDivProps {}\n\nconst DialogOverlayImpl = React.forwardRef<DialogOverlayImplElement, DialogOverlayImplProps>(\n  (props: ScopedProps<DialogOverlayImplProps>, forwardedRef) => {\n    const { __scopeDialog, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);\n    return (\n      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`\n      // ie. when `Overlay` and `Content` are siblings\n      <RemoveScroll as={Slot} allowPinchZoom={context.allowPinchZoom} shards={[context.contentRef]}>\n        <Primitive.div\n          data-state={getState(context.open)}\n          {...overlayProps}\n          ref={forwardedRef}\n          // We re-enable pointer-events prevented by `Dialog.Content` to allow scrolling the overlay.\n          style={{ pointerEvents: 'auto', ...overlayProps.style }}\n        />\n      </RemoveScroll>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * DialogContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'DialogContent';\n\ntype DialogContentElement = DialogContentTypeElement;\ninterface DialogContentProps extends DialogContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogContent = React.forwardRef<DialogContentElement, DialogContentProps>(\n  (props: ScopedProps<DialogContentProps>, forwardedRef) => {\n    const { forceMount, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    return (\n      <Presence present={forceMount || context.open}>\n        {context.modal ? (\n          <DialogContentModal {...contentProps} ref={forwardedRef} />\n        ) : (\n          <DialogContentNonModal {...contentProps} ref={forwardedRef} />\n        )}\n      </Presence>\n    );\n  }\n);\n\nDialogContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DialogContentTypeElement = DialogContentImplElement;\ninterface DialogContentTypeProps\n  extends Omit<DialogContentImplProps, 'trapFocus' | 'disableOutsidePointerEvents'> {}\n\nconst DialogContentModal = React.forwardRef<DialogContentTypeElement, DialogContentTypeProps>(\n  (props: ScopedProps<DialogContentTypeProps>, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);\n\n    // aria-hide everything except the content (better supported equivalent to setting aria-modal)\n    React.useEffect(() => {\n      const content = contentRef.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <DialogContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure focus isn't trapped once `DialogContent` has been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        disableOutsidePointerEvents\n        onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          event.preventDefault();\n          context.triggerRef.current?.focus();\n        })}\n        onPointerDownOutside={composeEventHandlers(props.onPointerDownOutside, (event) => {\n          const originalEvent = event.detail.originalEvent;\n          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n\n          // If the event is a right-click, we shouldn't close because\n          // it is effectively as if we right-clicked the `Overlay`.\n          if (isRightClick) event.preventDefault();\n        })}\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) =>\n          event.preventDefault()\n        )}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst DialogContentNonModal = React.forwardRef<DialogContentTypeElement, DialogContentTypeProps>(\n  (props: ScopedProps<DialogContentTypeProps>, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const hasInteractedOutsideRef = React.useRef(false);\n\n    return (\n      <DialogContentImpl\n        {...props}\n        ref={forwardedRef}\n        trapFocus={false}\n        disableOutsidePointerEvents={false}\n        onCloseAutoFocus={(event) => {\n          props.onCloseAutoFocus?.(event);\n\n          if (!event.defaultPrevented) {\n            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();\n            // Always prevent auto focus because we either focus manually or want user agent focus\n            event.preventDefault();\n          }\n\n          hasInteractedOutsideRef.current = false;\n        }}\n        onInteractOutside={(event) => {\n          props.onInteractOutside?.(event);\n\n          if (!event.defaultPrevented) hasInteractedOutsideRef.current = true;\n\n          // Prevent dismissing when clicking the trigger.\n          // As the trigger is already setup to close, without doing so would\n          // cause it to close and immediately open.\n          //\n          // We use `onInteractOutside` as some browsers also\n          // focus on pointer down, creating the same issue.\n          const target = event.target as HTMLElement;\n          const targetIsTrigger = context.triggerRef.current?.contains(target);\n          if (targetIsTrigger) event.preventDefault();\n        }}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DialogContentImplElement = React.ElementRef<typeof DismissableLayer>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype FocusScopeProps = Radix.ComponentPropsWithoutRef<typeof FocusScope>;\ninterface DialogContentImplProps extends Omit<DismissableLayerProps, 'onDismiss'> {\n  /**\n   * When `true`, focus cannot escape the `Content` via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n\n  /**\n   * Event handler called when auto-focusing on open.\n   * Can be prevented.\n   */\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n}\n\nconst DialogContentImpl = React.forwardRef<DialogContentImplElement, DialogContentImplProps>(\n  (props: ScopedProps<DialogContentImplProps>, forwardedRef) => {\n    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, __scopeDialog);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef);\n\n    // Make sure the whole tree has focus guards as our `Dialog` will be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    return (\n      <>\n        <FocusScope\n          asChild\n          loop\n          trapped={trapFocus}\n          onMountAutoFocus={onOpenAutoFocus}\n          onUnmountAutoFocus={onCloseAutoFocus}\n        >\n          <DismissableLayer\n            role=\"dialog\"\n            id={context.contentId}\n            aria-describedby={context.descriptionId}\n            aria-labelledby={context.titleId}\n            data-state={getState(context.open)}\n            {...contentProps}\n            ref={composedRefs}\n            onDismiss={() => context.onOpenChange(false)}\n          />\n        </FocusScope>\n        {process.env.NODE_ENV !== 'production' && (\n          <>\n            <TitleWarning contentRef={contentRef} />\n            <DescriptionWarning contentRef={contentRef} />\n          </>\n        )}\n      </>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * DialogTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'DialogTitle';\n\ntype DialogTitleElement = React.ElementRef<typeof Primitive.h2>;\ntype PrimitiveHeading2Props = Radix.ComponentPropsWithoutRef<typeof Primitive.h2>;\ninterface DialogTitleProps extends PrimitiveHeading2Props {}\n\nconst DialogTitle = React.forwardRef<DialogTitleElement, DialogTitleProps>(\n  (props: ScopedProps<DialogTitleProps>, forwardedRef) => {\n    const { __scopeDialog, ...titleProps } = props;\n    const context = useDialogContext(TITLE_NAME, __scopeDialog);\n    return <Primitive.h2 id={context.titleId} {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nDialogTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'DialogDescription';\n\ntype DialogDescriptionElement = React.ElementRef<typeof Primitive.p>;\ntype PrimitiveParagraphProps = Radix.ComponentPropsWithoutRef<typeof Primitive.p>;\ninterface DialogDescriptionProps extends PrimitiveParagraphProps {}\n\nconst DialogDescription = React.forwardRef<DialogDescriptionElement, DialogDescriptionProps>(\n  (props: ScopedProps<DialogDescriptionProps>, forwardedRef) => {\n    const { __scopeDialog, ...descriptionProps } = props;\n    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);\n    return <Primitive.p id={context.descriptionId} {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nDialogDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'DialogClose';\n\ntype DialogCloseElement = React.ElementRef<typeof Primitive.button>;\ninterface DialogCloseProps extends PrimitiveButtonProps {}\n\nconst DialogClose = React.forwardRef<DialogCloseElement, DialogCloseProps>(\n  (props: ScopedProps<DialogCloseProps>, forwardedRef) => {\n    const { __scopeDialog, ...closeProps } = props;\n    const context = useDialogContext(CLOSE_NAME, __scopeDialog);\n    return (\n      <Primitive.button\n        type=\"button\"\n        {...closeProps}\n        ref={forwardedRef}\n        onClick={composeEventHandlers(props.onClick, () => context.onOpenChange(false))}\n      />\n    );\n  }\n);\n\nDialogClose.displayName = CLOSE_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nconst TITLE_WARNING_NAME = 'DialogTitleWarning';\n\nconst [WarningProvider, useWarningContext] = createContext(TITLE_WARNING_NAME, {\n  contentName: CONTENT_NAME,\n  titleName: TITLE_NAME,\n  docsSlug: 'dialog',\n});\n\ntype WarningProps = {\n  contentRef: React.RefObject<DialogContentElement>;\n};\n\nconst TitleWarning: React.FC<WarningProps> = ({ contentRef }) => {\n  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);\n\n  const MESSAGE = `\\`${titleWarningContext.contentName}\\` requires a \\`${titleWarningContext.titleName}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${titleWarningContext.titleName}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;\n\n  React.useEffect(() => {\n    const hasLabel =\n      contentRef.current?.getAttribute('aria-label') ||\n      document.getElementById(contentRef.current?.getAttribute('aria-labelledby')!);\n\n    if (!hasLabel) throw new Error(MESSAGE);\n  }, [MESSAGE, contentRef]);\n\n  return null;\n};\n\nconst DESCRIPTION_WARNING_NAME = 'DialogDescriptionWarning';\n\nconst DescriptionWarning: React.FC<WarningProps> = ({ contentRef }) => {\n  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);\n\n  const MESSAGE = `Warning: Missing \\`Description\\` or \\`aria-describedby={undefined}\\` for {${descriptionWarningContext.contentName}}.`;\n\n  React.useEffect(() => {\n    const describedById = contentRef.current?.getAttribute('aria-describedby');\n    if (describedById) {\n      const hasDescription = document.getElementById(describedById);\n      if (describedById && !hasDescription) console.warn(MESSAGE);\n    }\n  }, [MESSAGE, contentRef]);\n\n  return null;\n};\n\nconst Root = Dialog;\nconst Trigger = DialogTrigger;\nconst Portal = DialogPortal;\nconst Overlay = DialogOverlay;\nconst Content = DialogContent;\nconst Title = DialogTitle;\nconst Description = DialogDescription;\nconst Close = DialogClose;\n\nexport {\n  createDialogScope,\n  //\n  Dialog,\n  DialogTrigger,\n  DialogPortal,\n  DialogOverlay,\n  DialogContent,\n  DialogTitle,\n  DialogDescription,\n  DialogClose,\n  //\n  Root,\n  Trigger,\n  Portal,\n  Overlay,\n  Content,\n  Title,\n  Description,\n  Close,\n  //\n  WarningProvider,\n};\nexport type {\n  DialogProps,\n  DialogTriggerProps,\n  DialogPortalProps,\n  DialogOverlayProps,\n  DialogContentProps,\n  DialogTitleProps,\n  DialogDescriptionProps,\n  DialogCloseProps,\n};\n"],
  "mappings": "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",
  "names": ["Slot", "forwardRef", "props", "forwardedRef", "children", "slotProps", "Children", "toArray", "some", "isSlottable", "createElement", "Fragment", "map", "child", "$d34e8c328cb3dd19ab7a2f6eafa6ad$var$SlotClone", "_babelRuntimeHelpersEsmExtends", "ref", "displayName", "SlotClone", "isValidElement", "cloneElement", "mergeProps", "composeRefs", "count", "only", "Slottable", "type", "childProps", "overrideProps", "propName", "slotPropValue", "childPropValue", "test", "args", "filter", "Boolean", "join", "count", "useFocusGuards", "React", "useEffect", "_edgeGuards$", "_edgeGuards$2", "edgeGuards", "document", "querySelectorAll", "body", "insertAdjacentElement", "createFocusGuard", "count", "forEach", "node", "remove", "element", "createElement", "setAttribute", "tabIndex", "style", "cssText", "Portal", "forwardRef", "props", "forwardedRef", "_containerRef$current", "_globalThis$document", "containerRef", "style", "portalProps", "hostElement", "current", "globalThis", "document", "body", "forceUpdate", "useState", "useLayoutEffect", "ReactDOM", "createPortal", "createElement", "Primitive", "div", "_babelRuntimeHelpersEsmExtends", "ref", "position", "top", "left", "zIndex", "undefined", "UnstablePortal", "_globalThis$document2", "container", "EVENT_OPTIONS", "bubbles", "cancelable", "FocusScope", "forwardRef", "props", "forwardedRef", "loop", "trapped", "onMountAutoFocus", "onMountAutoFocusProp", "onUnmountAutoFocus", "onUnmountAutoFocusProp", "scopeProps", "container", "setContainer", "useState", "useCallbackRef", "lastFocusedElementRef", "useRef", "composedRefs", "useComposedRefs", "node", "focusScope", "paused", "pause", "this", "resume", "current", "React", "useEffect", "handleFocusIn", "event", "target", "contains", "focus", "select", "handleFocusOut", "relatedTarget", "document", "addEventListener", "removeEventListener", "focusScopesStack", "add", "previouslyFocusedElement", "activeElement", "mountEvent", "Event", "dispatchEvent", "defaultPrevented", "candidates", "candidate", "items", "getTabbableCandidates", "filter", "item", "tagName", "setTimeout", "unmountEvent", "body", "remove", "handleKeyDown", "useCallback", "isTabKey", "key", "altKey", "ctrlKey", "metaKey", "focusedElement", "currentTarget", "first", "last", "findVisible", "reverse", "shiftKey", "preventDefault", "createElement", "Primitive", "div", "_babelRuntimeHelpersEsmExtends", "tabIndex", "ref", "onKeyDown", "nodes", "walker", "createTreeWalker", "NodeFilter", "SHOW_ELEMENT", "acceptNode", "isHiddenInput", "type", "disabled", "hidden", "FILTER_SKIP", "FILTER_ACCEPT", "nextNode", "push", "currentNode", "elements", "element", "isHidden", "upTo", "getComputedStyle", "visibility", "display", "parentElement", "preventScroll", "HTMLInputElement", "stack", "activeFocusScope", "arrayRemove", "unshift", "_stack$", "createFocusScopesStack", "array", "updatedArray", "index", "indexOf", "splice", "useEscapeKeydown", "onEscapeKeyDownProp", "onEscapeKeyDown", "useCallbackRef", "React", "useEffect", "handleKeyDown", "event", "key", "document", "addEventListener", "removeEventListener", "originalBodyPointerEvents", "changeCount", "useBodyPointerEvents", "disabled", "isTouchOrPenPressedRef", "useRef", "useLayoutEffect", "resetPointerEvents", "document", "body", "style", "pointerEvents", "handlePointerUp", "event", "current", "pointerType", "addEventListener", "once", "removeEventListener", "DismissableLayerContext", "createContext", "layers", "Set", "layersWithOutsidePointerEventsDisabled", "branches", "DismissableLayer", "forwardRef", "props", "forwardedRef", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "layerProps", "context", "useContext", "node", "setNode", "useState", "force", "composedRefs", "useComposedRefs", "Array", "from", "highestLayerWithOutsidePointerEventsDisabled", "slice", "highestLayerWithOutsidePointerEventsDisabledIndex", "indexOf", "index", "isBodyPointerEventsDisabled", "size", "isPointerEventsEnabled", "pointerDownOutside", "handlePointerDownOutside", "useCallbackRef", "isPointerInsideReactTreeRef", "useRef", "useEffect", "handlePointerDown", "event", "target", "current", "dispatchCustomEvent", "originalEvent", "timerId", "window", "setTimeout", "document", "addEventListener", "clearTimeout", "removeEventListener", "onPointerDownCapture", "isPointerDownOnBranch", "some", "branch", "contains", "defaultPrevented", "focusOutside", "handleFocusOutside", "isFocusInsideReactTreeRef", "handleFocus", "onFocusCapture", "onBlurCapture", "useEscapeKeydown", "useBodyPointerEvents", "disabled", "add", "dispatchUpdate", "delete", "handleUpdate", "createElement", "Primitive", "div", "_babelRuntimeHelpersEsmExtends", "ref", "style", "pointerEvents", "undefined", "composeEventHandlers", "DismissableLayerBranch", "Event", "dispatchEvent", "name", "handler", "detail", "CustomEvent", "bubbles", "cancelable", "once", "createDialogContext", "createDialogScope", "createContextScope", "DialogProvider", "useDialogContext", "createDialogContext", "Dialog", "props", "__scopeDialog", "children", "open", "openProp", "defaultOpen", "onOpenChange", "modal", "allowPinchZoom", "triggerRef", "useRef", "contentRef", "setOpen", "useControllableState", "prop", "defaultProp", "onChange", "createElement", "$da81f3af863821fb8a193d321c41d$var$DialogProvider", "scope", "contentId", "useId", "titleId", "descriptionId", "onOpenToggle", "useCallback", "prevOpen", "DialogTrigger", "forwardRef", "forwardedRef", "triggerProps", "context", "composedTriggerRef", "useComposedRefs", "Primitive", "button", "_babelRuntimeHelpersEsmExtends", "type", "getState", "ref", "onClick", "composeEventHandlers", "DialogPortal", "forceMount", "container", "Fragment", "Children", "map", "child", "Presence", "present", "UnstablePortal", "asChild", "DialogOverlay", "overlayProps", "$da81f3af863821fb8a193d321c41d$var$DialogOverlayImpl", "DialogOverlayImpl", "RemoveScroll", "as", "Slot", "shards", "div", "style", "pointerEvents", "DialogContent", "contentProps", "$da81f3af863821fb8a193d321c41d$var$DialogContentModal", "$da81f3af863821fb8a193d321c41d$var$DialogContentNonModal", "DialogContentModal", "composedRefs", "useEffect", "content", "current", "hideOthers", "$da81f3af863821fb8a193d321c41d$var$DialogContentImpl", "trapFocus", "disableOutsidePointerEvents", "onCloseAutoFocus", "event", "_context$triggerRef$c", "preventDefault", "focus", "onPointerDownOutside", "originalEvent", "detail", "ctrlLeftClick", "ctrlKey", "onFocusOutside", "DialogContentNonModal", "hasInteractedOutsideRef", "_props$onCloseAutoFoc", "_context$triggerRef$c2", "call", "defaultPrevented", "onInteractOutside", "_props$onInteractOuts", "_context$triggerRef$c3", "target", "contains", "DialogContentImpl", "onOpenAutoFocus", "useFocusGuards", "FocusScope", "loop", "trapped", "onMountAutoFocus", "onUnmountAutoFocus", "DismissableLayer", "role", "id", "onDismiss", "DialogTitle", "titleProps", "h2", "DialogDescription", "descriptionProps", "p", "DialogClose", "closeProps", "WarningProvider", "useWarningContext", "createContext", "contentName", "titleName", "docsSlug", "Root", "Dialog", "Trigger", "DialogTrigger", "Portal", "DialogPortal", "Overlay", "DialogOverlay", "Content", "DialogContent", "Title", "DialogTitle", "Description", "DialogDescription", "Close", "DialogClose"]
}
