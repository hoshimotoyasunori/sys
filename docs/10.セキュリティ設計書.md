# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆæ›¸

## 1. æ¦‚è¦

### 1.1 ç›®çš„
æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆã«ã¤ã„ã¦è©³ç´°ã«å®šç¾©ã™ã‚‹ã€‚

### 1.2 å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ 
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: React 18 + TypeScript
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**: Supabase (PostgreSQL + Auth + Realtime)
- **èªè¨¼**: Supabase Auth (JWT)
- **é€šä¿¡**: HTTPS/TLS 1.3

### 1.3 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ–¹é‡
- **ã‚¼ãƒ­ãƒˆãƒ©ã‚¹ãƒˆ**: å…¨ã¦ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æ¤œè¨¼
- **æœ€å°æ¨©é™**: å¿…è¦æœ€å°é™ã®æ¨©é™ã®ã¿ä»˜ä¸
- **å¤šå±¤é˜²å¾¡**: è¤‡æ•°ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å±¤ã§ä¿è­·
- **ç¶™ç¶šçš„ç›£è¦–**: 24æ™‚é–“365æ—¥ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–

## 2. è„…å¨åˆ†æ

### 2.1 è„…å¨ãƒ¢ãƒ‡ãƒ«

| è„…å¨ | ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ« | å½±éŸ¿ | å¯¾ç­– |
|------|-------------|------|------|
| SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ | é«˜ | ãƒ‡ãƒ¼ã‚¿æ¼æ´©ã€æ”¹ã–ã‚“ | ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒªã€RLS |
| XSSï¼ˆã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒ†ã‚£ãƒ³ã‚°ï¼‰ | é«˜ | ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¹—ã£å–ã‚Š | å…¥åŠ›æ¤œè¨¼ã€CSP |
| CSRFï¼ˆã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒ•ã‚©ãƒ¼ã‚¸ã‚§ãƒªï¼‰ | ä¸­ | ä¸æ­£æ“ä½œ | CSRFãƒˆãƒ¼ã‚¯ãƒ³ã€SameSite |
| èªè¨¼ãƒã‚¤ãƒ‘ã‚¹ | é«˜ | ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹ | å¤šè¦ç´ èªè¨¼ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç† |
| ãƒ‡ãƒ¼ã‚¿æ¼æ´© | é«˜ | æ©Ÿå¯†æƒ…å ±æµå‡º | æš—å·åŒ–ã€ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ |
| DDoSæ”»æ’ƒ | ä¸­ | ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢ | ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã€CDN |

### 2.2 ãƒªã‚¹ã‚¯è©•ä¾¡

```typescript
// src/lib/security/risk-assessment.ts
interface SecurityRisk {
  id: string
  threat: string
  likelihood: 'low' | 'medium' | 'high'
  impact: 'low' | 'medium' | 'high'
  riskLevel: 'low' | 'medium' | 'high' | 'critical'
  mitigation: string[]
}

export const securityRisks: SecurityRisk[] = [
  {
    id: 'AUTH-001',
    threat: 'èªè¨¼ãƒã‚¤ãƒ‘ã‚¹',
    likelihood: 'medium',
    impact: 'high',
    riskLevel: 'high',
    mitigation: [
      'å¤šè¦ç´ èªè¨¼ã®å®Ÿè£…',
      'ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®è¨­å®š',
      'å¼·åŠ›ãªãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒªã‚·ãƒ¼'
    ]
  },
  {
    id: 'DATA-001',
    threat: 'ãƒ‡ãƒ¼ã‚¿æ¼æ´©',
    likelihood: 'low',
    impact: 'high',
    riskLevel: 'high',
    mitigation: [
      'ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–',
      'ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã®å¼·åŒ–',
      'ç›£æŸ»ãƒ­ã‚°ã®å®Ÿè£…'
    ]
  }
]
```

## 3. èªè¨¼ãƒ»èªå¯è¨­è¨ˆ

### 3.1 èªè¨¼ãƒ•ãƒ­ãƒ¼

```typescript
// src/lib/auth/authentication.ts
interface AuthConfig {
  sessionTimeout: number // 30åˆ†
  refreshTokenExpiry: number // 7æ—¥
  maxLoginAttempts: number // 5å›
  lockoutDuration: number // 15åˆ†
}

export const authConfig: AuthConfig = {
  sessionTimeout: 30 * 60 * 1000,
  refreshTokenExpiry: 7 * 24 * 60 * 60 * 1000,
  maxLoginAttempts: 5,
  lockoutDuration: 15 * 60 * 1000
}

class AuthenticationManager {
  private loginAttempts = new Map<string, number>()
  private lockoutTimes = new Map<string, number>()

  async authenticate(email: string, password: string): Promise<AuthResult> {
    // ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒ­ãƒƒã‚¯ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
    if (this.isAccountLocked(email)) {
      throw new Error('Account is temporarily locked')
    }

    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password
      })

      if (error) {
        this.recordFailedAttempt(email)
        throw error
      }

      // æˆåŠŸæ™‚ã¯ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œå›æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
      this.loginAttempts.delete(email)
      
      return {
        success: true,
        user: data.user,
        session: data.session
      }
    } catch (error) {
      throw error
    }
  }

  private isAccountLocked(email: string): boolean {
    const lockoutTime = this.lockoutTimes.get(email)
    if (!lockoutTime) return false

    return Date.now() < lockoutTime
  }

  private recordFailedAttempt(email: string) {
    const attempts = (this.loginAttempts.get(email) || 0) + 1
    this.loginAttempts.set(email, attempts)

    if (attempts >= authConfig.maxLoginAttempts) {
      this.lockoutTimes.set(email, Date.now() + authConfig.lockoutDuration)
    }
  }
}

export const authManager = new AuthenticationManager()
```

### 3.2 èªå¯è¨­è¨ˆ

```sql
-- Row Level Security (RLS) ãƒãƒªã‚·ãƒ¼
-- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«
CREATE POLICY "Users can view their own projects" ON projects
  FOR SELECT USING (
    auth.uid() = created_by OR
    auth.uid() IN (
      SELECT user_id FROM project_members 
      WHERE project_id = id
    )
  );

CREATE POLICY "Users can update their own projects" ON projects
  FOR UPDATE USING (
    auth.uid() = created_by OR
    auth.uid() IN (
      SELECT user_id FROM project_members 
      WHERE project_id = id AND role IN ('owner', 'admin')
    )
  );

CREATE POLICY "Only owners can delete projects" ON projects
  FOR DELETE USING (auth.uid() = created_by);

-- ã‚¿ã‚¹ã‚¯ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE POLICY "Users can view tasks in their projects" ON tasks
  FOR SELECT USING (
    project_id IN (
      SELECT project_id FROM project_members 
      WHERE user_id = auth.uid()
    )
  );

CREATE POLICY "Users can update tasks in their projects" ON tasks
  FOR UPDATE USING (
    project_id IN (
      SELECT project_id FROM project_members 
      WHERE user_id = auth.uid() AND role IN ('owner', 'admin', 'member')
    )
  );
```

### 3.3 ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†

```typescript
// src/lib/auth/session-manager.ts
interface SessionInfo {
  userId: string
  sessionId: string
  createdAt: number
  lastActivity: number
  ipAddress: string
  userAgent: string
}

class SessionManager {
  private sessions = new Map<string, SessionInfo>()

  createSession(userId: string, sessionId: string, ipAddress: string, userAgent: string): SessionInfo {
    const session: SessionInfo = {
      userId,
      sessionId,
      createdAt: Date.now(),
      lastActivity: Date.now(),
      ipAddress,
      userAgent
    }

    this.sessions.set(sessionId, session)
    return session
  }

  validateSession(sessionId: string, ipAddress: string): boolean {
    const session = this.sessions.get(sessionId)
    if (!session) return false

    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯
    if (Date.now() - session.lastActivity > authConfig.sessionTimeout) {
      this.sessions.delete(sessionId)
      return false
    }

    // IPã‚¢ãƒ‰ãƒ¬ã‚¹å¤‰æ›´ã®æ¤œå‡º
    if (session.ipAddress !== ipAddress) {
      this.sessions.delete(sessionId)
      return false
    }

    // æœ€çµ‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’æ›´æ–°
    session.lastActivity = Date.now()
    return true
  }

  revokeSession(sessionId: string) {
    this.sessions.delete(sessionId)
  }

  revokeAllUserSessions(userId: string) {
    for (const [sessionId, session] of this.sessions.entries()) {
      if (session.userId === userId) {
        this.sessions.delete(sessionId)
      }
    }
  }
}

export const sessionManager = new SessionManager()
```

## 4. ãƒ‡ãƒ¼ã‚¿ä¿è­·

### 4.1 ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

```typescript
// src/lib/security/encryption.ts
import { createCipheriv, createDecipheriv, randomBytes, scrypt } from 'crypto'
import { promisify } from 'util'

const scryptAsync = promisify(scrypt)

export class DataEncryption {
  private algorithm = 'aes-256-gcm'
  private keyLength = 32
  private ivLength = 16
  private saltLength = 64
  private tagLength = 16

  async encryptSensitiveData(data: string, password: string): Promise<string> {
    const salt = randomBytes(this.saltLength)
    const iv = randomBytes(this.ivLength)
    
    const key = await scryptAsync(password, salt, this.keyLength) as Buffer
    const cipher = createCipheriv(this.algorithm, key, iv)
    
    let encrypted = cipher.update(data, 'utf8', 'hex')
    encrypted += cipher.final('hex')
    
    const tag = cipher.getAuthTag()
    
    // salt:iv:tag:encrypted
    return `${salt.toString('hex')}:${iv.toString('hex')}:${tag.toString('hex')}:${encrypted}`
  }

  async decryptSensitiveData(encryptedData: string, password: string): Promise<string> {
    const [saltHex, ivHex, tagHex, encrypted] = encryptedData.split(':')
    
    const salt = Buffer.from(saltHex, 'hex')
    const iv = Buffer.from(ivHex, 'hex')
    const tag = Buffer.from(tagHex, 'hex')
    
    const key = await scryptAsync(password, salt, this.keyLength) as Buffer
    const decipher = createDecipheriv(this.algorithm, key, iv)
    
    decipher.setAuthTag(tag)
    
    let decrypted = decipher.update(encrypted, 'hex', 'utf8')
    decrypted += decipher.final('utf8')
    
    return decrypted
  }
}

export const dataEncryption = new DataEncryption()
```

### 4.2 ãƒ‡ãƒ¼ã‚¿ãƒã‚¹ã‚­ãƒ³ã‚°

```typescript
// src/lib/security/data-masking.ts
export class DataMasking {
  maskEmail(email: string): string {
    const [local, domain] = email.split('@')
    const maskedLocal = local.length > 2 
      ? local.charAt(0) + '*'.repeat(local.length - 2) + local.charAt(local.length - 1)
      : local
    return `${maskedLocal}@${domain}`
  }

  maskPhoneNumber(phone: string): string {
    return phone.replace(/(\d{3})(\d{4})(\d{4})/, '$1-****-$3')
  }

  maskCreditCard(cardNumber: string): string {
    return cardNumber.replace(/(\d{4})(\d{4})(\d{4})(\d{4})/, '$1-****-****-$4')
  }

  maskSensitiveField(value: string, type: 'email' | 'phone' | 'credit_card'): string {
    switch (type) {
      case 'email':
        return this.maskEmail(value)
      case 'phone':
        return this.maskPhoneNumber(value)
      case 'credit_card':
        return this.maskCreditCard(value)
      default:
        return value
    }
  }
}

export const dataMasking = new DataMasking()
```

## 5. å…¥åŠ›æ¤œè¨¼ãƒ»ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

### 5.1 å…¥åŠ›æ¤œè¨¼

```typescript
// src/lib/security/input-validation.ts
import { z } from 'zod'

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆã‚¹ã‚­ãƒ¼ãƒ
export const createProjectSchema = z.object({
  name: z.string()
    .min(1, 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã¯å¿…é ˆã§ã™')
    .max(100, 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã¯100æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„')
    .regex(/^[a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF\s\-_]+$/, 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåã«ä½¿ç”¨ã§ããªã„æ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã¾ã™'),
  description: z.string()
    .max(1000, 'èª¬æ˜ã¯1000æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„')
    .optional(),
  members: z.array(z.object({
    email: z.string().email('æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'),
    role: z.enum(['owner', 'admin', 'member'])
  })).optional()
})

// ã‚¿ã‚¹ã‚¯ä½œæˆã‚¹ã‚­ãƒ¼ãƒ
export const createTaskSchema = z.object({
  title: z.string()
    .min(1, 'ã‚¿ã‚¹ã‚¯åã¯å¿…é ˆã§ã™')
    .max(200, 'ã‚¿ã‚¹ã‚¯åã¯200æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„'),
  description: z.string()
    .max(2000, 'èª¬æ˜ã¯2000æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„')
    .optional(),
  status: z.enum(['todo', 'in_progress', 'done']),
  priority: z.enum(['low', 'medium', 'high']).optional(),
  assigned_to: z.string().uuid().optional(),
  due_date: z.string().datetime().optional()
})

// XSSå¯¾ç­–
export const sanitizeHtml = (html: string): string => {
  return html
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;')
}

// SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–
export const sanitizeSql = (input: string): string => {
  return input
    .replace(/'/g, "''")
    .replace(/--/g, '')
    .replace(/;/, '')
    .replace(/\/\*/, '')
    .replace(/\*\//, '')
}
```

### 5.2 ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

```typescript
// src/lib/security/file-upload.ts
interface FileValidation {
  allowedTypes: string[]
  maxSize: number // bytes
  maxFiles: number
}

export class FileUploadSecurity {
  private validation: FileValidation = {
    allowedTypes: ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'],
    maxSize: 10 * 1024 * 1024, // 10MB
    maxFiles: 5
  }

  validateFile(file: File): { valid: boolean; error?: string } {
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
    if (!this.validation.allowedTypes.includes(file.type)) {
      return {
        valid: false,
        error: 'è¨±å¯ã•ã‚Œã¦ã„ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ã‚¤ãƒ—ã§ã™'
      }
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
    if (file.size > this.validation.maxSize) {
      return {
        valid: false,
        error: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™'
      }
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«åã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
    const sanitizedName = this.sanitizeFileName(file.name)
    if (sanitizedName !== file.name) {
      return {
        valid: false,
        error: 'ãƒ•ã‚¡ã‚¤ãƒ«åã«ä½¿ç”¨ã§ããªã„æ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã¾ã™'
      }
    }

    return { valid: true }
  }

  private sanitizeFileName(fileName: string): string {
    return fileName
      .replace(/[^a-zA-Z0-9._-]/g, '_')
      .replace(/_{2,}/g, '_')
      .replace(/^_|_$/g, '')
  }

  async scanForMalware(file: File): Promise<boolean> {
    // ãƒãƒ«ã‚¦ã‚§ã‚¢ã‚¹ã‚­ãƒ£ãƒ³ã®å®Ÿè£…
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯å¤–éƒ¨ã®ãƒãƒ«ã‚¦ã‚§ã‚¢ã‚¹ã‚­ãƒ£ãƒ³APIã‚’ä½¿ç”¨
    return true
  }
}

export const fileUploadSecurity = new FileUploadSecurity()
```

## 6. é€šä¿¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

### 6.1 HTTPS/TLSè¨­å®š

```typescript
// src/lib/security/transport-security.ts
export const transportSecurityConfig = {
  // TLS 1.3ã®ã¿è¨±å¯
  minTlsVersion: 'TLSv1.3',
  
  // å¼·åŠ›ãªæš—å·ã‚¹ã‚¤ãƒ¼ãƒˆ
  cipherSuites: [
    'TLS_AES_256_GCM_SHA384',
    'TLS_CHACHA20_POLY1305_SHA256',
    'TLS_AES_128_GCM_SHA256'
  ],
  
  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼
  securityHeaders: {
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Content-Security-Policy': "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
    'Referrer-Policy': 'strict-origin-when-cross-origin'
  }
}

// CSPï¼ˆContent Security Policyï¼‰è¨­å®š
export const cspConfig = {
  'default-src': ["'self'"],
  'script-src': ["'self'", "'unsafe-inline'"],
  'style-src': ["'self'", "'unsafe-inline'"],
  'img-src': ["'self'", 'data:', 'https:'],
  'connect-src': ["'self'", 'https://*.supabase.co'],
  'frame-src': ["'none'"],
  'object-src': ["'none'"],
  'base-uri': ["'self'"],
  'form-action': ["'self'"]
}
```

### 6.2 APIã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£

```typescript
// src/lib/security/api-security.ts
export class ApiSecurity {
  private rateLimitMap = new Map<string, { count: number; resetTime: number }>()
  private maxRequests = 100 // 1åˆ†é–“ã«100ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  private windowMs = 60000 // 1åˆ†

  checkRateLimit(ipAddress: string): boolean {
    const now = Date.now()
    const record = this.rateLimitMap.get(ipAddress)

    if (!record || now > record.resetTime) {
      this.rateLimitMap.set(ipAddress, {
        count: 1,
        resetTime: now + this.windowMs
      })
      return true
    }

    if (record.count >= this.maxRequests) {
      return false
    }

    record.count++
    return true
  }

  validateApiKey(apiKey: string): boolean {
    // APIã‚­ãƒ¼ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
    return apiKey === process.env.API_KEY
  }

  sanitizeApiResponse(data: any): any {
    // æ©Ÿå¯†æƒ…å ±ã®é™¤å»
    const sanitized = { ...data }
    delete sanitized.password
    delete sanitized.token
    delete sanitized.secret
    return sanitized
  }
}

export const apiSecurity = new ApiSecurity()
```

## 7. ç›£æŸ»ãƒ­ã‚°

### 7.1 ç›£æŸ»ãƒ­ã‚°è¨­è¨ˆ

```sql
-- ç›£æŸ»ãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  action VARCHAR(100) NOT NULL,
  resource_type VARCHAR(50) NOT NULL,
  resource_id UUID,
  details JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ç›£æŸ»ãƒ­ã‚°ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_audit_logs_user_id ON audit_logs(user_id);
CREATE INDEX idx_audit_logs_action ON audit_logs(action);
CREATE INDEX idx_audit_logs_created_at ON audit_logs(created_at);
CREATE INDEX idx_audit_logs_resource ON audit_logs(resource_type, resource_id);

-- ç›£æŸ»ãƒ­ã‚°ãƒˆãƒªã‚¬ãƒ¼
CREATE OR REPLACE FUNCTION log_project_changes()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO audit_logs (user_id, action, resource_type, resource_id, details)
    VALUES (auth.uid(), 'CREATE', 'project', NEW.id, jsonb_build_object('name', NEW.name));
  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO audit_logs (user_id, action, resource_type, resource_id, details)
    VALUES (auth.uid(), 'UPDATE', 'project', NEW.id, jsonb_build_object('changes', jsonb_build_object('name', OLD.name, 'new_name', NEW.name)));
  ELSIF TG_OP = 'DELETE' THEN
    INSERT INTO audit_logs (user_id, action, resource_type, resource_id, details)
    VALUES (auth.uid(), 'DELETE', 'project', OLD.id, jsonb_build_object('name', OLD.name));
  END IF;
  RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER project_audit_trigger
  AFTER INSERT OR UPDATE OR DELETE ON projects
  FOR EACH ROW EXECUTE FUNCTION log_project_changes();
```

### 7.2 ç›£æŸ»ãƒ­ã‚°å®Ÿè£…

```typescript
// src/lib/security/audit-logger.ts
interface AuditLogEntry {
  userId?: string
  action: string
  resourceType: string
  resourceId?: string
  details?: any
  ipAddress?: string
  userAgent?: string
}

export class AuditLogger {
  async log(entry: AuditLogEntry) {
    try {
      const { data, error } = await supabase
        .from('audit_logs')
        .insert({
          user_id: entry.userId,
          action: entry.action,
          resource_type: entry.resourceType,
          resource_id: entry.resourceId,
          details: entry.details,
          ip_address: entry.ipAddress,
          user_agent: entry.userAgent
        })

      if (error) {
        console.error('Failed to log audit entry:', error)
      }
    } catch (error) {
      console.error('Audit logging failed:', error)
    }
  }

  async getAuditLogs(filters: {
    userId?: string
    action?: string
    resourceType?: string
    startDate?: Date
    endDate?: Date
  }) {
    let query = supabase
      .from('audit_logs')
      .select('*')
      .order('created_at', { ascending: false })

    if (filters.userId) {
      query = query.eq('user_id', filters.userId)
    }
    if (filters.action) {
      query = query.eq('action', filters.action)
    }
    if (filters.resourceType) {
      query = query.eq('resource_type', filters.resourceType)
    }
    if (filters.startDate) {
      query = query.gte('created_at', filters.startDate.toISOString())
    }
    if (filters.endDate) {
      query = query.lte('created_at', filters.endDate.toISOString())
    }

    return await query
  }
}

export const auditLogger = new AuditLogger()
```

## 8. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–

### 8.1 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ™ãƒ³ãƒˆç›£è¦–

```typescript
// src/lib/security/security-monitor.ts
interface SecurityEvent {
  type: 'login_attempt' | 'data_access' | 'privilege_escalation' | 'suspicious_activity'
  severity: 'low' | 'medium' | 'high' | 'critical'
  userId?: string
  ipAddress: string
  userAgent: string
  details: any
  timestamp: Date
}

export class SecurityMonitor {
  private events: SecurityEvent[] = []
  private alertThresholds = {
    failedLogins: 5,
    suspiciousActivities: 3,
    dataAccessViolations: 1
  }

  recordEvent(event: SecurityEvent) {
    this.events.push(event)
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æ
    this.analyzeEvent(event)
    
    // ã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ
    if (this.shouldAlert(event)) {
      this.generateAlert(event)
    }
  }

  private analyzeEvent(event: SecurityEvent) {
    switch (event.type) {
      case 'login_attempt':
        this.analyzeLoginAttempt(event)
        break
      case 'data_access':
        this.analyzeDataAccess(event)
        break
      case 'suspicious_activity':
        this.analyzeSuspiciousActivity(event)
        break
    }
  }

  private analyzeLoginAttempt(event: SecurityEvent) {
    const recentFailures = this.events.filter(e => 
      e.type === 'login_attempt' &&
      e.ipAddress === event.ipAddress &&
      e.timestamp > new Date(Date.now() - 15 * 60 * 1000) // 15åˆ†ä»¥å†…
    ).length

    if (recentFailures >= this.alertThresholds.failedLogins) {
      this.blockIP(event.ipAddress, 30 * 60 * 1000) // 30åˆ†ãƒ–ãƒ­ãƒƒã‚¯
    }
  }

  private shouldAlert(event: SecurityEvent): boolean {
    return event.severity === 'high' || event.severity === 'critical'
  }

  private generateAlert(event: SecurityEvent) {
    const alert = {
      title: `Security Alert: ${event.type}`,
      severity: event.severity,
      details: event,
      timestamp: new Date().toISOString()
    }

    // ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
    this.sendSecurityAlert(alert)
  }

  private sendSecurityAlert(alert: any) {
    // Slacké€šçŸ¥
    fetch(process.env.SECURITY_SLACK_WEBHOOK!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text: `ğŸš¨ Security Alert: ${alert.title}`,
        attachments: [{
          color: alert.severity === 'critical' ? 'danger' : 'warning',
          fields: [
            { title: 'Severity', value: alert.severity, short: true },
            { title: 'IP Address', value: alert.details.ipAddress, short: true },
            { title: 'Details', value: JSON.stringify(alert.details, null, 2) }
          ]
        }]
      })
    })
  }

  private blockIP(ipAddress: string, duration: number) {
    // IPãƒ–ãƒ­ãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯
    console.log(`Blocking IP ${ipAddress} for ${duration}ms`)
  }
}

export const securityMonitor = new SecurityMonitor()
```

ã“ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆã«ã‚ˆã‚Šã€åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¿è­·ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚ 