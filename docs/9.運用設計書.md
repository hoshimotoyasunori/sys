# é‹ç”¨è¨­è¨ˆæ›¸

## 1. æ¦‚è¦

### 1.1 ç›®çš„
æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€ã‚·ã‚¹ãƒ†ãƒ è¨­è¨ˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®é‹ç”¨è¨­è¨ˆã«ã¤ã„ã¦è©³ç´°ã«å®šç¾©ã™ã‚‹ã€‚

### 1.2 å¯¾è±¡ã‚·ã‚¹ãƒ†ãƒ 
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: React 18 + Vite (Vercelãƒ‡ãƒ—ãƒ­ã‚¤)
- **ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**: Supabase (PostgreSQL + Auth + Realtime)
- **ç›£è¦–**: Vercel Analytics + Supabase Monitoring
- **CI/CD**: GitHub Actions

### 1.3 é‹ç”¨æ–¹é‡
- **é«˜å¯ç”¨æ€§**: 99.9%ä»¥ä¸Šã®ç¨¼åƒç‡ã‚’ç›®æ¨™
- **è‡ªå‹•åŒ–**: å¯èƒ½ãªé™ã‚Šé‹ç”¨ä½œæ¥­ã‚’è‡ªå‹•åŒ–
- **ç›£è¦–**: 24æ™‚é–“365æ—¥ã®ç¶™ç¶šç›£è¦–
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã®æ—©æœŸç™ºè¦‹ãƒ»å¯¾å¿œ

## 2. ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨­è¨ˆ

### 2.1 Vercelãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆè¨­å®š

```json
// vercel.json
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist"
      }
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/index.html"
    }
  ],
  "env": {
    "VITE_SUPABASE_URL": "@supabase-url",
    "VITE_SUPABASE_ANON_KEY": "@supabase-anon-key"
  },
  "functions": {
    "api/**/*.ts": {
      "runtime": "@vercel/node@18"
    }
  }
}
```

### 2.2 GitHub Actions CI/CD

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run tests
      run: npm run test:ci
    
    - name: Build
      run: npm run build
      env:
        VITE_SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
        VITE_SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Deploy to Vercel
      uses: amondnet/vercel-action@v25
      with:
        vercel-token: ${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
        vercel-args: '--prod'
```

### 2.3 ç’°å¢ƒåˆ¥è¨­å®š

```typescript
// src/config/environment.ts
export const environment = {
  development: {
    supabaseUrl: 'http://localhost:54321',
    supabaseAnonKey: 'your-local-anon-key',
    apiUrl: 'http://localhost:5173',
    enableDebug: true
  },
  staging: {
    supabaseUrl: process.env.VITE_SUPABASE_URL,
    supabaseAnonKey: process.env.VITE_SUPABASE_ANON_KEY,
    apiUrl: 'https://staging.yourapp.vercel.app',
    enableDebug: true
  },
  production: {
    supabaseUrl: process.env.VITE_SUPABASE_URL,
    supabaseAnonKey: process.env.VITE_SUPABASE_ANON_KEY,
    apiUrl: 'https://yourapp.vercel.app',
    enableDebug: false
  }
}

export const getCurrentEnvironment = () => {
  const env = process.env.NODE_ENV || 'development'
  return environment[env as keyof typeof environment]
}
```

## 3. ç›£è¦–è¨­è¨ˆ

### 3.1 Vercel Analyticsè¨­å®š

```typescript
// src/lib/analytics.ts
import { Analytics } from '@vercel/analytics/react'

export const AnalyticsProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <>
      {children}
      <Analytics />
    </>
  )
}

// ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ™ãƒ³ãƒˆè¿½è·¡
export const trackEvent = (eventName: string, properties?: Record<string, any>) => {
  if (typeof window !== 'undefined' && window.gtag) {
    window.gtag('event', eventName, properties)
  }
}

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
export const trackPerformance = () => {
  if (typeof window !== 'undefined' && 'performance' in window) {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'navigation') {
          const navEntry = entry as PerformanceNavigationTiming
          trackEvent('page_load_time', {
            load_time: navEntry.loadEventEnd - navEntry.loadEventStart,
            dom_content_loaded: navEntry.domContentLoadedEventEnd - navEntry.domContentLoadedEventStart
          })
        }
      }
    })
    
    observer.observe({ entryTypes: ['navigation'] })
  }
}
```

### 3.2 Supabaseç›£è¦–è¨­å®š

```sql
-- ç›£è¦–ç”¨ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
CREATE VIEW system_health AS
SELECT 
  'database_size' as metric,
  pg_size_pretty(pg_database_size(current_database())) as value
UNION ALL
SELECT 
  'active_connections',
  count(*)::text
FROM pg_stat_activity
WHERE state = 'active'
UNION ALL
SELECT 
  'slow_queries',
  count(*)::text
FROM pg_stat_activity
WHERE query_start < now() - interval '5 minutes'
  AND state = 'active';

-- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚¯ã‚¨ãƒª
CREATE VIEW performance_metrics AS
SELECT 
  schemaname,
  tablename,
  seq_scan,
  seq_tup_read,
  idx_scan,
  idx_tup_fetch,
  n_tup_ins,
  n_tup_upd,
  n_tup_del,
  n_live_tup,
  n_dead_tup
FROM pg_stat_user_tables
ORDER BY n_live_tup DESC;
```

### 3.3 ã‚¨ãƒ©ãƒ¼ç›£è¦–

```typescript
// src/lib/error-monitoring.ts
import * as Sentry from '@sentry/react'

export const initializeErrorMonitoring = () => {
  if (process.env.NODE_ENV === 'production') {
    Sentry.init({
      dsn: process.env.VITE_SENTRY_DSN,
      environment: process.env.NODE_ENV,
      integrations: [
        new Sentry.BrowserTracing({
          routingInstrumentation: Sentry.reactRouterV6Instrumentation(
            history => history
          ),
        }),
      ],
      tracesSampleRate: 0.1,
    })
  }
}

// ã‚¨ãƒ©ãƒ¼ãƒã‚¦ãƒ³ãƒ€ãƒª
export const ErrorBoundary = ({ children }: { children: React.ReactNode }) => {
  return (
    <Sentry.ErrorBoundary
      fallback={({ error, componentStack, resetError }) => (
        <div className="error-boundary">
          <h2>ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</h2>
          <p>äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚</p>
          <button onClick={resetError}>å†è©¦è¡Œ</button>
        </div>
      )}
    >
      {children}
    </Sentry.ErrorBoundary>
  )
}

// ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
export const handleError = (error: Error, context?: string) => {
  console.error('Error occurred:', error)
  
  if (process.env.NODE_ENV === 'production') {
    Sentry.captureException(error, {
      tags: { context },
      extra: { errorMessage: error.message }
    })
  }
}
```

## 4. ãƒ­ã‚°ç®¡ç†

### 4.1 ãƒ­ã‚°è¨­å®š

```typescript
// src/lib/logger.ts
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

class Logger {
  private level: LogLevel

  constructor(level: LogLevel = LogLevel.INFO) {
    this.level = level
  }

  private formatMessage(level: string, message: string, data?: any): string {
    const timestamp = new Date().toISOString()
    const logData = data ? ` | ${JSON.stringify(data)}` : ''
    return `[${timestamp}] ${level}: ${message}${logData}`
  }

  debug(message: string, data?: any) {
    if (this.level <= LogLevel.DEBUG) {
      console.debug(this.formatMessage('DEBUG', message, data))
    }
  }

  info(message: string, data?: any) {
    if (this.level <= LogLevel.INFO) {
      console.info(this.formatMessage('INFO', message, data))
    }
  }

  warn(message: string, data?: any) {
    if (this.level <= LogLevel.WARN) {
      console.warn(this.formatMessage('WARN', message, data))
    }
  }

  error(message: string, error?: Error, data?: any) {
    if (this.level <= LogLevel.ERROR) {
      console.error(this.formatMessage('ERROR', message, data))
      if (error) {
        console.error(error.stack)
      }
    }
  }
}

export const logger = new Logger(
  process.env.NODE_ENV === 'development' ? LogLevel.DEBUG : LogLevel.INFO
)
```

### 4.2 ãƒ­ã‚°åé›†

```typescript
// src/lib/log-collector.ts
interface LogEntry {
  timestamp: string
  level: string
  message: string
  data?: any
  userId?: string
  sessionId?: string
}

class LogCollector {
  private logs: LogEntry[] = []
  private maxLogs = 1000
  private flushInterval = 30000 // 30ç§’

  constructor() {
    setInterval(() => this.flush(), this.flushInterval)
  }

  addLog(entry: LogEntry) {
    this.logs.push(entry)
    
    if (this.logs.length > this.maxLogs) {
      this.logs.shift()
    }
  }

  private async flush() {
    if (this.logs.length === 0) return

    try {
      const logsToSend = [...this.logs]
      this.logs = []

      await fetch('/api/logs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(logsToSend)
      })
    } catch (error) {
      console.error('Failed to flush logs:', error)
      // å¤±æ•—ã—ãŸãƒ­ã‚°ã‚’å†åº¦è¿½åŠ 
      this.logs.unshift(...this.logs)
    }
  }
}

export const logCollector = new LogCollector()
```

## 5. ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æˆ¦ç•¥

### 5.1 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—

```sql
-- è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è¨­å®šï¼ˆSupabaseç®¡ç†ï¼‰
-- æ—¥æ¬¡ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
-- ãƒã‚¤ãƒ³ãƒˆã‚¤ãƒ³ã‚¿ã‚¤ãƒ ãƒªã‚«ãƒãƒªï¼ˆPITRï¼‰æœ‰åŠ¹
-- 7æ—¥é–“ã®ä¿æŒæœŸé–“

-- æ‰‹å‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
CREATE OR REPLACE FUNCTION create_backup()
RETURNS void AS $$
BEGIN
  -- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  COPY (
    SELECT 
      p.id as project_id,
      p.name as project_name,
      p.description as project_description,
      p.created_at as project_created_at,
      u.email as creator_email,
      pm.role as member_role,
      t.title as task_title,
      t.status as task_status,
      d.name as deliverable_name,
      d.status as deliverable_status,
      d.due_date as deliverable_due_date
    FROM projects p
    LEFT JOIN users u ON p.created_by = u.id
    LEFT JOIN project_members pm ON p.id = pm.project_id
    LEFT JOIN users um ON pm.user_id = um.id
    LEFT JOIN tasks t ON p.id = t.project_id
    LEFT JOIN deliverables d ON p.id = d.project_id
  ) TO '/tmp/project_backup.csv' WITH CSV HEADER;
END;
$$ LANGUAGE plpgsql;
```

### 5.2 ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—

```typescript
// scripts/backup.ts
import { createClient } from '@supabase/supabase-js'
import { writeFileSync, mkdirSync } from 'fs'
import { join } from 'path'

const supabase = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
)

export const createBackup = async () => {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
  const backupDir = join(process.cwd(), 'backups', timestamp)
  
  mkdirSync(backupDir, { recursive: true })

  try {
    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const { data: projects } = await supabase
      .from('projects')
      .select('*')
    
    writeFileSync(
      join(backupDir, 'projects.json'),
      JSON.stringify(projects, null, 2)
    )

    // ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const { data: tasks } = await supabase
      .from('tasks')
      .select('*')
    
    writeFileSync(
      join(backupDir, 'tasks.json'),
      JSON.stringify(tasks, null, 2)
    )

    // æˆæœç‰©ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    const { data: deliverables } = await supabase
      .from('deliverables')
      .select('*')
    
    writeFileSync(
      join(backupDir, 'deliverables.json'),
      JSON.stringify(deliverables, null, 2)
    )

    console.log(`Backup created successfully: ${backupDir}`)
  } catch (error) {
    console.error('Backup failed:', error)
    throw error
  }
}

// å®šæœŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
if (require.main === module) {
  createBackup()
    .then(() => process.exit(0))
    .catch(() => process.exit(1))
}
```

## 6. éšœå®³å¯¾å¿œ

### 6.1 éšœå®³æ¤œçŸ¥

```typescript
// src/lib/health-check.ts
interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy'
  checks: {
    database: boolean
    api: boolean
    auth: boolean
  }
  timestamp: string
}

export const healthCheck = async (): Promise<HealthStatus> => {
  const checks = {
    database: false,
    api: false,
    auth: false
  }

  try {
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šãƒã‚§ãƒƒã‚¯
    const { data, error } = await supabase
      .from('projects')
      .select('count')
      .limit(1)
    
    checks.database = !error

    // APIæ¥ç¶šãƒã‚§ãƒƒã‚¯
    const apiResponse = await fetch('/api/health')
    checks.api = apiResponse.ok

    // èªè¨¼ã‚µãƒ¼ãƒ“ã‚¹ãƒã‚§ãƒƒã‚¯
    const { data: authData } = await supabase.auth.getSession()
    checks.auth = !!authData.session

  } catch (error) {
    console.error('Health check failed:', error)
  }

  const status = Object.values(checks).every(check => check)
    ? 'healthy'
    : Object.values(checks).some(check => check)
    ? 'degraded'
    : 'unhealthy'

  return {
    status,
    checks,
    timestamp: new Date().toISOString()
  }
}

// å®šæœŸçš„ãªãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
export const startHealthMonitoring = () => {
  setInterval(async () => {
    const health = await healthCheck()
    
    if (health.status !== 'healthy') {
      // ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
      sendAlert('System health degraded', health)
    }
    
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹é€ä¿¡
    trackMetric('system.health', health.status === 'healthy' ? 1 : 0)
  }, 60000) // 1åˆ†é–“éš”
}
```

### 6.2 éšœå®³å¯¾å¿œæ‰‹é †

```typescript
// src/lib/incident-response.ts
export enum IncidentSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

interface Incident {
  id: string
  severity: IncidentSeverity
  title: string
  description: string
  detectedAt: string
  resolvedAt?: string
  status: 'open' | 'investigating' | 'resolved'
}

class IncidentManager {
  private incidents: Incident[] = []

  createIncident(
    severity: IncidentSeverity,
    title: string,
    description: string
  ): Incident {
    const incident: Incident = {
      id: `incident-${Date.now()}`,
      severity,
      title,
      description,
      detectedAt: new Date().toISOString(),
      status: 'open'
    }

    this.incidents.push(incident)
    this.notifyTeam(incident)
    
    return incident
  }

  private notifyTeam(incident: Incident) {
    // Slacké€šçŸ¥
    if (incident.severity === IncidentSeverity.CRITICAL) {
      this.sendSlackAlert(incident)
    }
    
    // ãƒ¡ãƒ¼ãƒ«é€šçŸ¥
    if (incident.severity >= IncidentSeverity.HIGH) {
      this.sendEmailAlert(incident)
    }
  }

  private async sendSlackAlert(incident: Incident) {
    const message = {
      text: `ğŸš¨ Critical Incident Detected`,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*${incident.title}*\n${incident.description}`
          }
        },
        {
          type: 'section',
          fields: [
            { type: 'mrkdwn', text: `*Severity:* ${incident.severity}` },
            { type: 'mrkdwn', text: `*Detected:* ${incident.detectedAt}` }
          ]
        }
      ]
    }

    await fetch(process.env.SLACK_WEBHOOK_URL!, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(message)
    })
  }

  private async sendEmailAlert(incident: Incident) {
    // ãƒ¡ãƒ¼ãƒ«é€ä¿¡ãƒ­ã‚¸ãƒƒã‚¯
  }
}

export const incidentManager = new IncidentManager()
```

## 7. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

### 7.1 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–

```typescript
// src/lib/security-monitor.ts
interface SecurityEvent {
  type: 'login_attempt' | 'api_access' | 'data_access' | 'suspicious_activity'
  userId?: string
  ipAddress: string
  userAgent: string
  timestamp: string
  details: any
}

class SecurityMonitor {
  private events: SecurityEvent[] = []
  private suspiciousPatterns: RegExp[] = [
    /sqlmap/i,
    /nikto/i,
    /nmap/i,
    /admin.*login/i
  ]

  logEvent(event: SecurityEvent) {
    this.events.push(event)
    
    // ç–‘ã‚ã—ã„æ´»å‹•ã®æ¤œå‡º
    if (this.isSuspicious(event)) {
      this.handleSuspiciousActivity(event)
    }
    
    // ç•°å¸¸ãªãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œã®æ¤œå‡º
    if (event.type === 'login_attempt') {
      this.detectBruteForce(event)
    }
  }

  private isSuspicious(event: SecurityEvent): boolean {
    return this.suspiciousPatterns.some(pattern => 
      pattern.test(event.userAgent) || 
      pattern.test(JSON.stringify(event.details))
    )
  }

  private handleSuspiciousActivity(event: SecurityEvent) {
    console.warn('Suspicious activity detected:', event)
    
    // IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®ä¸€æ™‚çš„ãªãƒ–ãƒ­ãƒƒã‚¯
    this.blockIP(event.ipAddress, 3600000) // 1æ™‚é–“
    
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒ¼ãƒ ã¸ã®é€šçŸ¥
    this.notifySecurityTeam(event)
  }

  private detectBruteForce(event: SecurityEvent) {
    const recentAttempts = this.events.filter(e => 
      e.type === 'login_attempt' &&
      e.ipAddress === event.ipAddress &&
      new Date(e.timestamp).getTime() > Date.now() - 300000 // 5åˆ†ä»¥å†…
    )

    if (recentAttempts.length > 10) {
      console.warn('Brute force attack detected:', event.ipAddress)
      this.blockIP(event.ipAddress, 1800000) // 30åˆ†
    }
  }

  private blockIP(ipAddress: string, duration: number) {
    // IPãƒ–ãƒ­ãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯
    console.log(`Blocking IP ${ipAddress} for ${duration}ms`)
  }

  private notifySecurityTeam(event: SecurityEvent) {
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒ¼ãƒ é€šçŸ¥ãƒ­ã‚¸ãƒƒã‚¯
  }
}

export const securityMonitor = new SecurityMonitor()
```

### 7.2 ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–

```typescript
// src/lib/encryption.ts
import { createCipheriv, createDecipheriv, randomBytes } from 'crypto'

const ALGORITHM = 'aes-256-gcm'
const SECRET_KEY = process.env.ENCRYPTION_KEY!

export const encryptData = (data: string): string => {
  const iv = randomBytes(16)
  const cipher = createCipheriv(ALGORITHM, Buffer.from(SECRET_KEY, 'hex'), iv)
  
  let encrypted = cipher.update(data, 'utf8', 'hex')
  encrypted += cipher.final('hex')
  
  const authTag = cipher.getAuthTag()
  
  return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`
}

export const decryptData = (encryptedData: string): string => {
  const [ivHex, authTagHex, encrypted] = encryptedData.split(':')
  
  const iv = Buffer.from(ivHex, 'hex')
  const authTag = Buffer.from(authTagHex, 'hex')
  const decipher = createDecipheriv(ALGORITHM, Buffer.from(SECRET_KEY, 'hex'), iv)
  
  decipher.setAuthTag(authTag)
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8')
  decrypted += decipher.final('utf8')
  
  return decrypted
}
```

## 8. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–

### 8.1 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹

```typescript
// src/lib/performance-monitor.ts
interface PerformanceMetrics {
  pageLoadTime: number
  apiResponseTime: number
  memoryUsage: number
  cpuUsage: number
}

class PerformanceMonitor {
  private metrics: PerformanceMetrics[] = []

  trackPageLoad() {
    if (typeof window !== 'undefined') {
      window.addEventListener('load', () => {
        const loadTime = performance.now()
        this.recordMetric('pageLoadTime', loadTime)
      })
    }
  }

  trackApiCall(url: string, startTime: number) {
    const endTime = performance.now()
    const responseTime = endTime - startTime
    
    this.recordMetric('apiResponseTime', responseTime)
    
    // é…ã„APIã‚³ãƒ¼ãƒ«ã®æ¤œå‡º
    if (responseTime > 5000) { // 5ç§’ä»¥ä¸Š
      this.alertSlowApi(url, responseTime)
    }
  }

  trackMemoryUsage() {
    if (typeof performance !== 'undefined' && performance.memory) {
      const memoryUsage = performance.memory.usedJSHeapSize
      this.recordMetric('memoryUsage', memoryUsage)
      
      // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®è­¦å‘Š
      if (memoryUsage > 100 * 1024 * 1024) { // 100MBä»¥ä¸Š
        this.alertHighMemoryUsage(memoryUsage)
      }
    }
  }

  private recordMetric(type: keyof PerformanceMetrics, value: number) {
    this.metrics.push({
      pageLoadTime: type === 'pageLoadTime' ? value : 0,
      apiResponseTime: type === 'apiResponseTime' ? value : 0,
      memoryUsage: type === 'memoryUsage' ? value : 0,
      cpuUsage: type === 'cpuUsage' ? value : 0
    } as PerformanceMetrics)

    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®é€ä¿¡
    this.sendMetrics(type, value)
  }

  private sendMetrics(type: string, value: number) {
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹é€ä¿¡ãƒ­ã‚¸ãƒƒã‚¯
    fetch('/api/metrics', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type, value, timestamp: Date.now() })
    }).catch(console.error)
  }

  private alertSlowApi(url: string, responseTime: number) {
    console.warn(`Slow API call detected: ${url} (${responseTime}ms)`)
  }

  private alertHighMemoryUsage(memoryUsage: number) {
    console.warn(`High memory usage detected: ${memoryUsage / 1024 / 1024}MB`)
  }
}

export const performanceMonitor = new PerformanceMonitor()
```

## 9. é‹ç”¨è‡ªå‹•åŒ–

### 9.1 è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°

```typescript
// scripts/auto-scaling.ts
interface ScalingMetrics {
  cpuUsage: number
  memoryUsage: number
  requestCount: number
  responseTime: number
}

class AutoScaler {
  private currentInstances = 1
  private maxInstances = 10
  private minInstances = 1

  async checkScalingNeeds(metrics: ScalingMetrics) {
    const shouldScaleUp = 
      metrics.cpuUsage > 80 ||
      metrics.memoryUsage > 80 ||
      metrics.responseTime > 2000 ||
      metrics.requestCount > 1000

    const shouldScaleDown = 
      metrics.cpuUsage < 30 &&
      metrics.memoryUsage < 30 &&
      metrics.responseTime < 500 &&
      metrics.requestCount < 100

    if (shouldScaleUp && this.currentInstances < this.maxInstances) {
      await this.scaleUp()
    } else if (shouldScaleDown && this.currentInstances > this.minInstances) {
      await this.scaleDown()
    }
  }

  private async scaleUp() {
    console.log('Scaling up...')
    this.currentInstances++
    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ã‚¸ãƒƒã‚¯
  }

  private async scaleDown() {
    console.log('Scaling down...')
    this.currentInstances--
    // ã‚¹ã‚±ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒ­ã‚¸ãƒƒã‚¯
  }
}

export const autoScaler = new AutoScaler()
```

### 9.2 è‡ªå‹•ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹

```typescript
// scripts/maintenance.ts
interface MaintenanceTask {
  name: string
  schedule: string // cronå¼
  handler: () => Promise<void>
  enabled: boolean
}

class MaintenanceScheduler {
  private tasks: MaintenanceTask[] = [
    {
      name: 'Database Cleanup',
      schedule: '0 2 * * *', // æ¯æ—¥åˆå‰2æ™‚
      handler: this.cleanupDatabase,
      enabled: true
    },
    {
      name: 'Log Rotation',
      schedule: '0 3 * * 0', // æ¯é€±æ—¥æ›œåˆå‰3æ™‚
      handler: this.rotateLogs,
      enabled: true
    },
    {
      name: 'Backup Creation',
      schedule: '0 1 * * *', // æ¯æ—¥åˆå‰1æ™‚
      handler: this.createBackup,
      enabled: true
    }
  ]

  start() {
    this.tasks.forEach(task => {
      if (task.enabled) {
        this.scheduleTask(task)
      }
    })
  }

  private scheduleTask(task: MaintenanceTask) {
    // cronã‚¸ãƒ§ãƒ–ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    console.log(`Scheduled task: ${task.name}`)
  }

  private async cleanupDatabase() {
    // å¤ã„ãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    await supabase
      .from('project_invitations')
      .delete()
      .lt('created_at', thirtyDaysAgo.toISOString())
  }

  private async rotateLogs() {
    // ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³
    console.log('Rotating logs...')
  }

  private async createBackup() {
    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä½œæˆ
    console.log('Creating backup...')
  }
}

export const maintenanceScheduler = new MaintenanceScheduler()
```

## 10. é‹ç”¨ãƒ¬ãƒãƒ¼ãƒˆ

### 10.1 å®šæœŸãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ

```typescript
// scripts/generate-operations-report.ts
interface OperationsReport {
  period: string
  uptime: number
  totalRequests: number
  averageResponseTime: number
  errorRate: number
  securityIncidents: number
  performanceIssues: number
}

export const generateOperationsReport = async (): Promise<OperationsReport> => {
  const now = new Date()
  const lastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)

  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®åé›†
  const metrics = await collectMetrics(lastWeek, now)
  
  const report: OperationsReport = {
    period: `${lastWeek.toISOString()} - ${now.toISOString()}`,
    uptime: calculateUptime(metrics),
    totalRequests: metrics.totalRequests,
    averageResponseTime: metrics.averageResponseTime,
    errorRate: metrics.errorRate,
    securityIncidents: metrics.securityIncidents,
    performanceIssues: metrics.performanceIssues
  }

  // ãƒ¬ãƒãƒ¼ãƒˆã®ä¿å­˜
  await saveReport(report)
  
  // ãƒãƒ¼ãƒ ã¸ã®é€šçŸ¥
  await notifyTeam(report)
  
  return report
}

const calculateUptime = (metrics: any): number => {
  const totalTime = metrics.totalTime || 1
  const downtime = metrics.downtime || 0
  return ((totalTime - downtime) / totalTime) * 100
}

const saveReport = async (report: OperationsReport) => {
  await supabase
    .from('operations_reports')
    .insert(report)
}

const notifyTeam = async (report: OperationsReport) => {
  const message = `
ğŸ“Š Operations Report

Period: ${report.period}
Uptime: ${report.uptime.toFixed(2)}%
Total Requests: ${report.totalRequests}
Average Response Time: ${report.averageResponseTime}ms
Error Rate: ${report.errorRate}%
Security Incidents: ${report.securityIncidents}
Performance Issues: ${report.performanceIssues}
  `

  // Slacké€šçŸ¥
  await fetch(process.env.SLACK_WEBHOOK_URL!, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: message })
  })
}
```

ã“ã®é‹ç”¨è¨­è¨ˆã«ã‚ˆã‚Šã€å®‰å®šã—ãŸã‚·ã‚¹ãƒ†ãƒ é‹ç”¨ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚ 